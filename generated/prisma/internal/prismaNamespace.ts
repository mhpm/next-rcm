
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * WARNING: This is an internal file that is subject to change!
 *
 * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘
 *
 * All exports from this file are wrapped under a `Prisma` namespace object in the client.ts file.
 * While this enables partial backward compatibility, it is not part of the stable public API.
 *
 * If you are looking for your Models, Enums, and Input Types, please import them from the respective
 * model files in the `model` directory!
 */

import * as runtime from "@prisma/client/runtime/client"
import type * as Prisma from "../models"
import { type PrismaClient } from "./class"

export type * from '../models'

export type DMMF = typeof runtime.DMMF

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

/**
 * Prisma Errors
 */

export const PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
export type PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError

export const PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
export type PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError

export const PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
export type PrismaClientRustPanicError = runtime.PrismaClientRustPanicError

export const PrismaClientInitializationError = runtime.PrismaClientInitializationError
export type PrismaClientInitializationError = runtime.PrismaClientInitializationError

export const PrismaClientValidationError = runtime.PrismaClientValidationError
export type PrismaClientValidationError = runtime.PrismaClientValidationError

/**
 * Re-export of sql-template-tag
 */
export const sql = runtime.sqltag
export const empty = runtime.empty
export const join = runtime.join
export const raw = runtime.raw
export const Sql = runtime.Sql
export type Sql = runtime.Sql



/**
 * Decimal.js
 */
export const Decimal = runtime.Decimal
export type Decimal = runtime.Decimal

export type DecimalJsLike = runtime.DecimalJsLike

/**
* Extensions
*/
export type Extension = runtime.Types.Extensions.UserArgs
export const getExtensionContext = runtime.Extensions.getExtensionContext
export type Args<T, F extends runtime.Operation> = runtime.Types.Public.Args<T, F>
export type Payload<T, F extends runtime.Operation = never> = runtime.Types.Public.Payload<T, F>
export type Result<T, A, F extends runtime.Operation> = runtime.Types.Public.Result<T, A, F>
export type Exact<A, W> = runtime.Types.Public.Exact<A, W>

export type PrismaVersion = {
  client: string
  engine: string
}

/**
 * Prisma Client JS version: 7.2.0
 * Query Engine version: 0c8ef2ce45c83248ab3df073180d5eda9e8be7a3
 */
export const prismaVersion: PrismaVersion = {
  client: "7.2.0",
  engine: "0c8ef2ce45c83248ab3df073180d5eda9e8be7a3"
}

/**
 * Utility Types
 */

export type Bytes = runtime.Bytes
export type JsonObject = runtime.JsonObject
export type JsonArray = runtime.JsonArray
export type JsonValue = runtime.JsonValue
export type InputJsonObject = runtime.InputJsonObject
export type InputJsonArray = runtime.InputJsonArray
export type InputJsonValue = runtime.InputJsonValue


export const NullTypes = {
  DbNull: runtime.NullTypes.DbNull as (new (secret: never) => typeof runtime.DbNull),
  JsonNull: runtime.NullTypes.JsonNull as (new (secret: never) => typeof runtime.JsonNull),
  AnyNull: runtime.NullTypes.AnyNull as (new (secret: never) => typeof runtime.AnyNull),
}
/**
 * Helper for filtering JSON entries that have `null` on the database (empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const DbNull = runtime.DbNull

/**
 * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const JsonNull = runtime.JsonNull

/**
 * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const AnyNull = runtime.AnyNull


type SelectAndInclude = {
  select: any
  include: any
}

type SelectAndOmit = {
  select: any
  omit: any
}

/**
 * From T, pick a set of properties whose keys are in the union K
 */
type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
};

export type Enumerable<T> = T | Array<T>;

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};

/**
 * SelectSubset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
 * Additionally, it validates, if both select and include are present. If the case, it errors.
 */
export type SelectSubset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : T extends SelectAndOmit
      ? 'Please either choose `select` or `omit`.'
      : {})

/**
 * Subset + Intersection
 * @desc From `T` pick properties that exist in `U` and intersect `K`
 */
export type SubsetIntersection<T, U, K> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  K

type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

/**
 * XOR is needed to have a real mutually exclusive union type
 * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
 */
export type XOR<T, U> =
  T extends object ?
  U extends object ?
    (Without<T, U> & U) | (Without<U, T> & T)
  : U : T


/**
 * Is T a Record?
 */
type IsObject<T extends any> = T extends Array<any>
? False
: T extends Date
? False
: T extends Uint8Array
? False
: T extends BigInt
? False
: T extends object
? True
: False


/**
 * If it's T[], return T
 */
export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

/**
 * From ts-toolbelt
 */

type __Either<O extends object, K extends Key> = Omit<O, K> &
  {
    // Merge all but K
    [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
  }[K]

type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

type _Either<
  O extends object,
  K extends Key,
  strict extends Boolean
> = {
  1: EitherStrict<O, K>
  0: EitherLoose<O, K>
}[strict]

export type Either<
  O extends object,
  K extends Key,
  strict extends Boolean = 1
> = O extends unknown ? _Either<O, K, strict> : never

export type Union = any

export type PatchUndefined<O extends object, O1 extends object> = {
  [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
} & {}

/** Helper Types for "Merge" **/
export type IntersectOf<U extends Union> = (
  U extends unknown ? (k: U) => void : never
) extends (k: infer I) => void
  ? I
  : never

export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
} & {};

type _Merge<U extends object> = IntersectOf<Overwrite<U, {
    [K in keyof U]-?: At<U, K>;
}>>;

type Key = string | number | symbol;
type AtStrict<O extends object, K extends Key> = O[K & keyof O];
type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
}[strict];

export type ComputeRaw<A extends any> = A extends Function ? A : {
  [K in keyof A]: A[K];
} & {};

export type OptionalFlat<O> = {
  [K in keyof O]?: O[K];
} & {};

type _Record<K extends keyof any, T> = {
  [P in K]: T;
};

// cause typescript not to expand types and preserve names
type NoExpand<T> = T extends unknown ? T : never;

// this type assumes the passed object is entirely optional
export type AtLeast<O extends object, K extends string> = NoExpand<
  O extends unknown
  ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
    | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
  : never>;

type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
/** End Helper Types for "Merge" **/

export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

export type Boolean = True | False

export type True = 1

export type False = 0

export type Not<B extends Boolean> = {
  0: 1
  1: 0
}[B]

export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
  ? 0 // anything `never` is false
  : A1 extends A2
  ? 1
  : 0

export type Has<U extends Union, U1 extends Union> = Not<
  Extends<Exclude<U1, U>, U1>
>

export type Or<B1 extends Boolean, B2 extends Boolean> = {
  0: {
    0: 0
    1: 1
  }
  1: {
    0: 1
    1: 1
  }
}[B1][B2]

export type Keys<U extends Union> = U extends unknown ? keyof U : never

export type GetScalarType<T, O> = O extends object ? {
  [P in keyof T]: P extends keyof O
    ? O[P]
    : never
} : never

type FieldPaths<
  T,
  U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
> = IsObject<T> extends True ? U : T

export type GetHavingFields<T> = {
  [K in keyof T]: Or<
    Or<Extends<'OR', K>, Extends<'AND', K>>,
    Extends<'NOT', K>
  > extends True
    ? // infer is only needed to not hit TS limit
      // based on the brilliant idea of Pierre-Antoine Mills
      // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
      T[K] extends infer TK
      ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
      : never
    : {} extends FieldPaths<T[K]>
    ? never
    : K
}[keyof T]

/**
 * Convert tuple to union
 */
type _TupleToUnion<T> = T extends (infer E)[] ? E : never
type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
export type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

/**
 * Like `Pick`, but additionally can also accept an array of keys
 */
export type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

/**
 * Exclude all keys with underscores
 */
export type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


export const ModelName = {
  Churches: 'Churches',
  Networks: 'Networks',
  Members: 'Members',
  Ministries: 'Ministries',
  Cells: 'Cells',
  Zones: 'Zones',
  Sectors: 'Sectors',
  SubSectors: 'SubSectors',
  Groups: 'Groups',
  GroupFields: 'GroupFields',
  CellGoals: 'CellGoals',
  Reports: 'Reports',
  ReportFields: 'ReportFields',
  ReportEntries: 'ReportEntries',
  ReportEntryValues: 'ReportEntryValues',
  MemberMinistry: 'MemberMinistry',
  Friends: 'Friends',
  Events: 'Events',
  EventAttendances: 'EventAttendances',
  EventPhases: 'EventPhases'
} as const

export type ModelName = (typeof ModelName)[keyof typeof ModelName]



export interface TypeMapCb<GlobalOmitOptions = {}> extends runtime.Types.Utils.Fn<{extArgs: runtime.Types.Extensions.InternalArgs }, runtime.Types.Utils.Record<string, any>> {
  returns: TypeMap<this['params']['extArgs'], GlobalOmitOptions>
}

export type TypeMap<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
  globalOmitOptions: {
    omit: GlobalOmitOptions
  }
  meta: {
    modelProps: "churches" | "networks" | "members" | "ministries" | "cells" | "zones" | "sectors" | "subSectors" | "groups" | "groupFields" | "cellGoals" | "reports" | "reportFields" | "reportEntries" | "reportEntryValues" | "memberMinistry" | "friends" | "events" | "eventAttendances" | "eventPhases"
    txIsolationLevel: TransactionIsolationLevel
  }
  model: {
    Churches: {
      payload: Prisma.$ChurchesPayload<ExtArgs>
      fields: Prisma.ChurchesFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ChurchesFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChurchesPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ChurchesFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChurchesPayload>
        }
        findFirst: {
          args: Prisma.ChurchesFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChurchesPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ChurchesFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChurchesPayload>
        }
        findMany: {
          args: Prisma.ChurchesFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChurchesPayload>[]
        }
        create: {
          args: Prisma.ChurchesCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChurchesPayload>
        }
        createMany: {
          args: Prisma.ChurchesCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ChurchesCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChurchesPayload>[]
        }
        delete: {
          args: Prisma.ChurchesDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChurchesPayload>
        }
        update: {
          args: Prisma.ChurchesUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChurchesPayload>
        }
        deleteMany: {
          args: Prisma.ChurchesDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ChurchesUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ChurchesUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChurchesPayload>[]
        }
        upsert: {
          args: Prisma.ChurchesUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChurchesPayload>
        }
        aggregate: {
          args: Prisma.ChurchesAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateChurches>
        }
        groupBy: {
          args: Prisma.ChurchesGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ChurchesGroupByOutputType>[]
        }
        count: {
          args: Prisma.ChurchesCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ChurchesCountAggregateOutputType> | number
        }
      }
    }
    Networks: {
      payload: Prisma.$NetworksPayload<ExtArgs>
      fields: Prisma.NetworksFieldRefs
      operations: {
        findUnique: {
          args: Prisma.NetworksFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NetworksPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.NetworksFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NetworksPayload>
        }
        findFirst: {
          args: Prisma.NetworksFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NetworksPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.NetworksFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NetworksPayload>
        }
        findMany: {
          args: Prisma.NetworksFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NetworksPayload>[]
        }
        create: {
          args: Prisma.NetworksCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NetworksPayload>
        }
        createMany: {
          args: Prisma.NetworksCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.NetworksCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NetworksPayload>[]
        }
        delete: {
          args: Prisma.NetworksDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NetworksPayload>
        }
        update: {
          args: Prisma.NetworksUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NetworksPayload>
        }
        deleteMany: {
          args: Prisma.NetworksDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.NetworksUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.NetworksUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NetworksPayload>[]
        }
        upsert: {
          args: Prisma.NetworksUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NetworksPayload>
        }
        aggregate: {
          args: Prisma.NetworksAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateNetworks>
        }
        groupBy: {
          args: Prisma.NetworksGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NetworksGroupByOutputType>[]
        }
        count: {
          args: Prisma.NetworksCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NetworksCountAggregateOutputType> | number
        }
      }
    }
    Members: {
      payload: Prisma.$MembersPayload<ExtArgs>
      fields: Prisma.MembersFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MembersFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MembersPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MembersFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MembersPayload>
        }
        findFirst: {
          args: Prisma.MembersFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MembersPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MembersFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MembersPayload>
        }
        findMany: {
          args: Prisma.MembersFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MembersPayload>[]
        }
        create: {
          args: Prisma.MembersCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MembersPayload>
        }
        createMany: {
          args: Prisma.MembersCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.MembersCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MembersPayload>[]
        }
        delete: {
          args: Prisma.MembersDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MembersPayload>
        }
        update: {
          args: Prisma.MembersUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MembersPayload>
        }
        deleteMany: {
          args: Prisma.MembersDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MembersUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.MembersUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MembersPayload>[]
        }
        upsert: {
          args: Prisma.MembersUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MembersPayload>
        }
        aggregate: {
          args: Prisma.MembersAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMembers>
        }
        groupBy: {
          args: Prisma.MembersGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MembersGroupByOutputType>[]
        }
        count: {
          args: Prisma.MembersCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MembersCountAggregateOutputType> | number
        }
      }
    }
    Ministries: {
      payload: Prisma.$MinistriesPayload<ExtArgs>
      fields: Prisma.MinistriesFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MinistriesFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MinistriesPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MinistriesFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MinistriesPayload>
        }
        findFirst: {
          args: Prisma.MinistriesFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MinistriesPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MinistriesFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MinistriesPayload>
        }
        findMany: {
          args: Prisma.MinistriesFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MinistriesPayload>[]
        }
        create: {
          args: Prisma.MinistriesCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MinistriesPayload>
        }
        createMany: {
          args: Prisma.MinistriesCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.MinistriesCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MinistriesPayload>[]
        }
        delete: {
          args: Prisma.MinistriesDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MinistriesPayload>
        }
        update: {
          args: Prisma.MinistriesUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MinistriesPayload>
        }
        deleteMany: {
          args: Prisma.MinistriesDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MinistriesUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.MinistriesUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MinistriesPayload>[]
        }
        upsert: {
          args: Prisma.MinistriesUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MinistriesPayload>
        }
        aggregate: {
          args: Prisma.MinistriesAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMinistries>
        }
        groupBy: {
          args: Prisma.MinistriesGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MinistriesGroupByOutputType>[]
        }
        count: {
          args: Prisma.MinistriesCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MinistriesCountAggregateOutputType> | number
        }
      }
    }
    Cells: {
      payload: Prisma.$CellsPayload<ExtArgs>
      fields: Prisma.CellsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CellsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CellsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CellsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CellsPayload>
        }
        findFirst: {
          args: Prisma.CellsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CellsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CellsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CellsPayload>
        }
        findMany: {
          args: Prisma.CellsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CellsPayload>[]
        }
        create: {
          args: Prisma.CellsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CellsPayload>
        }
        createMany: {
          args: Prisma.CellsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CellsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CellsPayload>[]
        }
        delete: {
          args: Prisma.CellsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CellsPayload>
        }
        update: {
          args: Prisma.CellsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CellsPayload>
        }
        deleteMany: {
          args: Prisma.CellsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CellsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CellsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CellsPayload>[]
        }
        upsert: {
          args: Prisma.CellsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CellsPayload>
        }
        aggregate: {
          args: Prisma.CellsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCells>
        }
        groupBy: {
          args: Prisma.CellsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CellsGroupByOutputType>[]
        }
        count: {
          args: Prisma.CellsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CellsCountAggregateOutputType> | number
        }
      }
    }
    Zones: {
      payload: Prisma.$ZonesPayload<ExtArgs>
      fields: Prisma.ZonesFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ZonesFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ZonesPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ZonesFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ZonesPayload>
        }
        findFirst: {
          args: Prisma.ZonesFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ZonesPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ZonesFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ZonesPayload>
        }
        findMany: {
          args: Prisma.ZonesFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ZonesPayload>[]
        }
        create: {
          args: Prisma.ZonesCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ZonesPayload>
        }
        createMany: {
          args: Prisma.ZonesCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ZonesCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ZonesPayload>[]
        }
        delete: {
          args: Prisma.ZonesDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ZonesPayload>
        }
        update: {
          args: Prisma.ZonesUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ZonesPayload>
        }
        deleteMany: {
          args: Prisma.ZonesDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ZonesUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ZonesUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ZonesPayload>[]
        }
        upsert: {
          args: Prisma.ZonesUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ZonesPayload>
        }
        aggregate: {
          args: Prisma.ZonesAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateZones>
        }
        groupBy: {
          args: Prisma.ZonesGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ZonesGroupByOutputType>[]
        }
        count: {
          args: Prisma.ZonesCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ZonesCountAggregateOutputType> | number
        }
      }
    }
    Sectors: {
      payload: Prisma.$SectorsPayload<ExtArgs>
      fields: Prisma.SectorsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SectorsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SectorsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SectorsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SectorsPayload>
        }
        findFirst: {
          args: Prisma.SectorsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SectorsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SectorsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SectorsPayload>
        }
        findMany: {
          args: Prisma.SectorsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SectorsPayload>[]
        }
        create: {
          args: Prisma.SectorsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SectorsPayload>
        }
        createMany: {
          args: Prisma.SectorsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SectorsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SectorsPayload>[]
        }
        delete: {
          args: Prisma.SectorsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SectorsPayload>
        }
        update: {
          args: Prisma.SectorsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SectorsPayload>
        }
        deleteMany: {
          args: Prisma.SectorsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SectorsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SectorsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SectorsPayload>[]
        }
        upsert: {
          args: Prisma.SectorsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SectorsPayload>
        }
        aggregate: {
          args: Prisma.SectorsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSectors>
        }
        groupBy: {
          args: Prisma.SectorsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SectorsGroupByOutputType>[]
        }
        count: {
          args: Prisma.SectorsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SectorsCountAggregateOutputType> | number
        }
      }
    }
    SubSectors: {
      payload: Prisma.$SubSectorsPayload<ExtArgs>
      fields: Prisma.SubSectorsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SubSectorsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubSectorsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SubSectorsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubSectorsPayload>
        }
        findFirst: {
          args: Prisma.SubSectorsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubSectorsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SubSectorsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubSectorsPayload>
        }
        findMany: {
          args: Prisma.SubSectorsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubSectorsPayload>[]
        }
        create: {
          args: Prisma.SubSectorsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubSectorsPayload>
        }
        createMany: {
          args: Prisma.SubSectorsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SubSectorsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubSectorsPayload>[]
        }
        delete: {
          args: Prisma.SubSectorsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubSectorsPayload>
        }
        update: {
          args: Prisma.SubSectorsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubSectorsPayload>
        }
        deleteMany: {
          args: Prisma.SubSectorsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SubSectorsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SubSectorsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubSectorsPayload>[]
        }
        upsert: {
          args: Prisma.SubSectorsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubSectorsPayload>
        }
        aggregate: {
          args: Prisma.SubSectorsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSubSectors>
        }
        groupBy: {
          args: Prisma.SubSectorsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SubSectorsGroupByOutputType>[]
        }
        count: {
          args: Prisma.SubSectorsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SubSectorsCountAggregateOutputType> | number
        }
      }
    }
    Groups: {
      payload: Prisma.$GroupsPayload<ExtArgs>
      fields: Prisma.GroupsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.GroupsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.GroupsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupsPayload>
        }
        findFirst: {
          args: Prisma.GroupsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.GroupsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupsPayload>
        }
        findMany: {
          args: Prisma.GroupsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupsPayload>[]
        }
        create: {
          args: Prisma.GroupsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupsPayload>
        }
        createMany: {
          args: Prisma.GroupsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.GroupsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupsPayload>[]
        }
        delete: {
          args: Prisma.GroupsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupsPayload>
        }
        update: {
          args: Prisma.GroupsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupsPayload>
        }
        deleteMany: {
          args: Prisma.GroupsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.GroupsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.GroupsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupsPayload>[]
        }
        upsert: {
          args: Prisma.GroupsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupsPayload>
        }
        aggregate: {
          args: Prisma.GroupsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateGroups>
        }
        groupBy: {
          args: Prisma.GroupsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GroupsGroupByOutputType>[]
        }
        count: {
          args: Prisma.GroupsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GroupsCountAggregateOutputType> | number
        }
      }
    }
    GroupFields: {
      payload: Prisma.$GroupFieldsPayload<ExtArgs>
      fields: Prisma.GroupFieldsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.GroupFieldsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupFieldsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.GroupFieldsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupFieldsPayload>
        }
        findFirst: {
          args: Prisma.GroupFieldsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupFieldsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.GroupFieldsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupFieldsPayload>
        }
        findMany: {
          args: Prisma.GroupFieldsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupFieldsPayload>[]
        }
        create: {
          args: Prisma.GroupFieldsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupFieldsPayload>
        }
        createMany: {
          args: Prisma.GroupFieldsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.GroupFieldsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupFieldsPayload>[]
        }
        delete: {
          args: Prisma.GroupFieldsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupFieldsPayload>
        }
        update: {
          args: Prisma.GroupFieldsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupFieldsPayload>
        }
        deleteMany: {
          args: Prisma.GroupFieldsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.GroupFieldsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.GroupFieldsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupFieldsPayload>[]
        }
        upsert: {
          args: Prisma.GroupFieldsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupFieldsPayload>
        }
        aggregate: {
          args: Prisma.GroupFieldsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateGroupFields>
        }
        groupBy: {
          args: Prisma.GroupFieldsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GroupFieldsGroupByOutputType>[]
        }
        count: {
          args: Prisma.GroupFieldsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GroupFieldsCountAggregateOutputType> | number
        }
      }
    }
    CellGoals: {
      payload: Prisma.$CellGoalsPayload<ExtArgs>
      fields: Prisma.CellGoalsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CellGoalsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CellGoalsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CellGoalsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CellGoalsPayload>
        }
        findFirst: {
          args: Prisma.CellGoalsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CellGoalsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CellGoalsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CellGoalsPayload>
        }
        findMany: {
          args: Prisma.CellGoalsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CellGoalsPayload>[]
        }
        create: {
          args: Prisma.CellGoalsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CellGoalsPayload>
        }
        createMany: {
          args: Prisma.CellGoalsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CellGoalsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CellGoalsPayload>[]
        }
        delete: {
          args: Prisma.CellGoalsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CellGoalsPayload>
        }
        update: {
          args: Prisma.CellGoalsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CellGoalsPayload>
        }
        deleteMany: {
          args: Prisma.CellGoalsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CellGoalsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CellGoalsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CellGoalsPayload>[]
        }
        upsert: {
          args: Prisma.CellGoalsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CellGoalsPayload>
        }
        aggregate: {
          args: Prisma.CellGoalsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCellGoals>
        }
        groupBy: {
          args: Prisma.CellGoalsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CellGoalsGroupByOutputType>[]
        }
        count: {
          args: Prisma.CellGoalsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CellGoalsCountAggregateOutputType> | number
        }
      }
    }
    Reports: {
      payload: Prisma.$ReportsPayload<ExtArgs>
      fields: Prisma.ReportsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ReportsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ReportsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportsPayload>
        }
        findFirst: {
          args: Prisma.ReportsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ReportsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportsPayload>
        }
        findMany: {
          args: Prisma.ReportsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportsPayload>[]
        }
        create: {
          args: Prisma.ReportsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportsPayload>
        }
        createMany: {
          args: Prisma.ReportsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ReportsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportsPayload>[]
        }
        delete: {
          args: Prisma.ReportsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportsPayload>
        }
        update: {
          args: Prisma.ReportsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportsPayload>
        }
        deleteMany: {
          args: Prisma.ReportsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ReportsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ReportsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportsPayload>[]
        }
        upsert: {
          args: Prisma.ReportsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportsPayload>
        }
        aggregate: {
          args: Prisma.ReportsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateReports>
        }
        groupBy: {
          args: Prisma.ReportsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ReportsGroupByOutputType>[]
        }
        count: {
          args: Prisma.ReportsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ReportsCountAggregateOutputType> | number
        }
      }
    }
    ReportFields: {
      payload: Prisma.$ReportFieldsPayload<ExtArgs>
      fields: Prisma.ReportFieldsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ReportFieldsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportFieldsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ReportFieldsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportFieldsPayload>
        }
        findFirst: {
          args: Prisma.ReportFieldsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportFieldsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ReportFieldsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportFieldsPayload>
        }
        findMany: {
          args: Prisma.ReportFieldsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportFieldsPayload>[]
        }
        create: {
          args: Prisma.ReportFieldsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportFieldsPayload>
        }
        createMany: {
          args: Prisma.ReportFieldsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ReportFieldsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportFieldsPayload>[]
        }
        delete: {
          args: Prisma.ReportFieldsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportFieldsPayload>
        }
        update: {
          args: Prisma.ReportFieldsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportFieldsPayload>
        }
        deleteMany: {
          args: Prisma.ReportFieldsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ReportFieldsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ReportFieldsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportFieldsPayload>[]
        }
        upsert: {
          args: Prisma.ReportFieldsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportFieldsPayload>
        }
        aggregate: {
          args: Prisma.ReportFieldsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateReportFields>
        }
        groupBy: {
          args: Prisma.ReportFieldsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ReportFieldsGroupByOutputType>[]
        }
        count: {
          args: Prisma.ReportFieldsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ReportFieldsCountAggregateOutputType> | number
        }
      }
    }
    ReportEntries: {
      payload: Prisma.$ReportEntriesPayload<ExtArgs>
      fields: Prisma.ReportEntriesFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ReportEntriesFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportEntriesPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ReportEntriesFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportEntriesPayload>
        }
        findFirst: {
          args: Prisma.ReportEntriesFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportEntriesPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ReportEntriesFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportEntriesPayload>
        }
        findMany: {
          args: Prisma.ReportEntriesFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportEntriesPayload>[]
        }
        create: {
          args: Prisma.ReportEntriesCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportEntriesPayload>
        }
        createMany: {
          args: Prisma.ReportEntriesCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ReportEntriesCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportEntriesPayload>[]
        }
        delete: {
          args: Prisma.ReportEntriesDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportEntriesPayload>
        }
        update: {
          args: Prisma.ReportEntriesUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportEntriesPayload>
        }
        deleteMany: {
          args: Prisma.ReportEntriesDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ReportEntriesUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ReportEntriesUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportEntriesPayload>[]
        }
        upsert: {
          args: Prisma.ReportEntriesUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportEntriesPayload>
        }
        aggregate: {
          args: Prisma.ReportEntriesAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateReportEntries>
        }
        groupBy: {
          args: Prisma.ReportEntriesGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ReportEntriesGroupByOutputType>[]
        }
        count: {
          args: Prisma.ReportEntriesCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ReportEntriesCountAggregateOutputType> | number
        }
      }
    }
    ReportEntryValues: {
      payload: Prisma.$ReportEntryValuesPayload<ExtArgs>
      fields: Prisma.ReportEntryValuesFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ReportEntryValuesFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportEntryValuesPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ReportEntryValuesFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportEntryValuesPayload>
        }
        findFirst: {
          args: Prisma.ReportEntryValuesFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportEntryValuesPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ReportEntryValuesFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportEntryValuesPayload>
        }
        findMany: {
          args: Prisma.ReportEntryValuesFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportEntryValuesPayload>[]
        }
        create: {
          args: Prisma.ReportEntryValuesCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportEntryValuesPayload>
        }
        createMany: {
          args: Prisma.ReportEntryValuesCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ReportEntryValuesCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportEntryValuesPayload>[]
        }
        delete: {
          args: Prisma.ReportEntryValuesDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportEntryValuesPayload>
        }
        update: {
          args: Prisma.ReportEntryValuesUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportEntryValuesPayload>
        }
        deleteMany: {
          args: Prisma.ReportEntryValuesDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ReportEntryValuesUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ReportEntryValuesUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportEntryValuesPayload>[]
        }
        upsert: {
          args: Prisma.ReportEntryValuesUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportEntryValuesPayload>
        }
        aggregate: {
          args: Prisma.ReportEntryValuesAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateReportEntryValues>
        }
        groupBy: {
          args: Prisma.ReportEntryValuesGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ReportEntryValuesGroupByOutputType>[]
        }
        count: {
          args: Prisma.ReportEntryValuesCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ReportEntryValuesCountAggregateOutputType> | number
        }
      }
    }
    MemberMinistry: {
      payload: Prisma.$MemberMinistryPayload<ExtArgs>
      fields: Prisma.MemberMinistryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MemberMinistryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberMinistryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MemberMinistryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberMinistryPayload>
        }
        findFirst: {
          args: Prisma.MemberMinistryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberMinistryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MemberMinistryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberMinistryPayload>
        }
        findMany: {
          args: Prisma.MemberMinistryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberMinistryPayload>[]
        }
        create: {
          args: Prisma.MemberMinistryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberMinistryPayload>
        }
        createMany: {
          args: Prisma.MemberMinistryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.MemberMinistryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberMinistryPayload>[]
        }
        delete: {
          args: Prisma.MemberMinistryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberMinistryPayload>
        }
        update: {
          args: Prisma.MemberMinistryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberMinistryPayload>
        }
        deleteMany: {
          args: Prisma.MemberMinistryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MemberMinistryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.MemberMinistryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberMinistryPayload>[]
        }
        upsert: {
          args: Prisma.MemberMinistryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberMinistryPayload>
        }
        aggregate: {
          args: Prisma.MemberMinistryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMemberMinistry>
        }
        groupBy: {
          args: Prisma.MemberMinistryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MemberMinistryGroupByOutputType>[]
        }
        count: {
          args: Prisma.MemberMinistryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MemberMinistryCountAggregateOutputType> | number
        }
      }
    }
    Friends: {
      payload: Prisma.$FriendsPayload<ExtArgs>
      fields: Prisma.FriendsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FriendsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FriendsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FriendsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FriendsPayload>
        }
        findFirst: {
          args: Prisma.FriendsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FriendsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FriendsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FriendsPayload>
        }
        findMany: {
          args: Prisma.FriendsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FriendsPayload>[]
        }
        create: {
          args: Prisma.FriendsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FriendsPayload>
        }
        createMany: {
          args: Prisma.FriendsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FriendsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FriendsPayload>[]
        }
        delete: {
          args: Prisma.FriendsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FriendsPayload>
        }
        update: {
          args: Prisma.FriendsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FriendsPayload>
        }
        deleteMany: {
          args: Prisma.FriendsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FriendsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FriendsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FriendsPayload>[]
        }
        upsert: {
          args: Prisma.FriendsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FriendsPayload>
        }
        aggregate: {
          args: Prisma.FriendsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFriends>
        }
        groupBy: {
          args: Prisma.FriendsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FriendsGroupByOutputType>[]
        }
        count: {
          args: Prisma.FriendsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FriendsCountAggregateOutputType> | number
        }
      }
    }
    Events: {
      payload: Prisma.$EventsPayload<ExtArgs>
      fields: Prisma.EventsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EventsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EventsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventsPayload>
        }
        findFirst: {
          args: Prisma.EventsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EventsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventsPayload>
        }
        findMany: {
          args: Prisma.EventsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventsPayload>[]
        }
        create: {
          args: Prisma.EventsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventsPayload>
        }
        createMany: {
          args: Prisma.EventsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EventsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventsPayload>[]
        }
        delete: {
          args: Prisma.EventsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventsPayload>
        }
        update: {
          args: Prisma.EventsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventsPayload>
        }
        deleteMany: {
          args: Prisma.EventsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EventsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EventsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventsPayload>[]
        }
        upsert: {
          args: Prisma.EventsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventsPayload>
        }
        aggregate: {
          args: Prisma.EventsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEvents>
        }
        groupBy: {
          args: Prisma.EventsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventsGroupByOutputType>[]
        }
        count: {
          args: Prisma.EventsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventsCountAggregateOutputType> | number
        }
      }
    }
    EventAttendances: {
      payload: Prisma.$EventAttendancesPayload<ExtArgs>
      fields: Prisma.EventAttendancesFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EventAttendancesFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAttendancesPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EventAttendancesFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAttendancesPayload>
        }
        findFirst: {
          args: Prisma.EventAttendancesFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAttendancesPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EventAttendancesFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAttendancesPayload>
        }
        findMany: {
          args: Prisma.EventAttendancesFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAttendancesPayload>[]
        }
        create: {
          args: Prisma.EventAttendancesCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAttendancesPayload>
        }
        createMany: {
          args: Prisma.EventAttendancesCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EventAttendancesCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAttendancesPayload>[]
        }
        delete: {
          args: Prisma.EventAttendancesDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAttendancesPayload>
        }
        update: {
          args: Prisma.EventAttendancesUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAttendancesPayload>
        }
        deleteMany: {
          args: Prisma.EventAttendancesDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EventAttendancesUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EventAttendancesUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAttendancesPayload>[]
        }
        upsert: {
          args: Prisma.EventAttendancesUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAttendancesPayload>
        }
        aggregate: {
          args: Prisma.EventAttendancesAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEventAttendances>
        }
        groupBy: {
          args: Prisma.EventAttendancesGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventAttendancesGroupByOutputType>[]
        }
        count: {
          args: Prisma.EventAttendancesCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventAttendancesCountAggregateOutputType> | number
        }
      }
    }
    EventPhases: {
      payload: Prisma.$EventPhasesPayload<ExtArgs>
      fields: Prisma.EventPhasesFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EventPhasesFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPhasesPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EventPhasesFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPhasesPayload>
        }
        findFirst: {
          args: Prisma.EventPhasesFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPhasesPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EventPhasesFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPhasesPayload>
        }
        findMany: {
          args: Prisma.EventPhasesFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPhasesPayload>[]
        }
        create: {
          args: Prisma.EventPhasesCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPhasesPayload>
        }
        createMany: {
          args: Prisma.EventPhasesCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EventPhasesCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPhasesPayload>[]
        }
        delete: {
          args: Prisma.EventPhasesDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPhasesPayload>
        }
        update: {
          args: Prisma.EventPhasesUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPhasesPayload>
        }
        deleteMany: {
          args: Prisma.EventPhasesDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EventPhasesUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EventPhasesUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPhasesPayload>[]
        }
        upsert: {
          args: Prisma.EventPhasesUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPhasesPayload>
        }
        aggregate: {
          args: Prisma.EventPhasesAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEventPhases>
        }
        groupBy: {
          args: Prisma.EventPhasesGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventPhasesGroupByOutputType>[]
        }
        count: {
          args: Prisma.EventPhasesCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventPhasesCountAggregateOutputType> | number
        }
      }
    }
  }
} & {
  other: {
    payload: any
    operations: {
      $executeRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $executeRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
      $queryRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $queryRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
    }
  }
}

/**
 * Enums
 */

export const TransactionIsolationLevel = runtime.makeStrictEnum({
  ReadUncommitted: 'ReadUncommitted',
  ReadCommitted: 'ReadCommitted',
  RepeatableRead: 'RepeatableRead',
  Serializable: 'Serializable'
} as const)

export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


export const ChurchesScalarFieldEnum = {
  id: 'id',
  name: 'name',
  slug: 'slug',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  owner_id: 'owner_id'
} as const

export type ChurchesScalarFieldEnum = (typeof ChurchesScalarFieldEnum)[keyof typeof ChurchesScalarFieldEnum]


export const NetworksScalarFieldEnum = {
  id: 'id',
  name: 'name',
  church_id: 'church_id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type NetworksScalarFieldEnum = (typeof NetworksScalarFieldEnum)[keyof typeof NetworksScalarFieldEnum]


export const MembersScalarFieldEnum = {
  id: 'id',
  firstName: 'firstName',
  lastName: 'lastName',
  email: 'email',
  phone: 'phone',
  age: 'age',
  street: 'street',
  city: 'city',
  state: 'state',
  zip: 'zip',
  country: 'country',
  birthDate: 'birthDate',
  baptismDate: 'baptismDate',
  role: 'role',
  gender: 'gender',
  pictureUrl: 'pictureUrl',
  notes: 'notes',
  passwordHash: 'passwordHash',
  church_id: 'church_id',
  zone_id: 'zone_id',
  sector_id: 'sector_id',
  sub_sector_id: 'sub_sector_id',
  cell_id: 'cell_id',
  network_id: 'network_id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type MembersScalarFieldEnum = (typeof MembersScalarFieldEnum)[keyof typeof MembersScalarFieldEnum]


export const MinistriesScalarFieldEnum = {
  id: 'id',
  name: 'name',
  description: 'description',
  church_id: 'church_id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  leader_id: 'leader_id'
} as const

export type MinistriesScalarFieldEnum = (typeof MinistriesScalarFieldEnum)[keyof typeof MinistriesScalarFieldEnum]


export const CellsScalarFieldEnum = {
  id: 'id',
  name: 'name',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  church_id: 'church_id',
  sub_sector_id: 'sub_sector_id',
  leader_id: 'leader_id',
  host_id: 'host_id',
  assistant_id: 'assistant_id',
  accessCode: 'accessCode'
} as const

export type CellsScalarFieldEnum = (typeof CellsScalarFieldEnum)[keyof typeof CellsScalarFieldEnum]


export const ZonesScalarFieldEnum = {
  id: 'id',
  name: 'name',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  church_id: 'church_id',
  supervisor_id: 'supervisor_id'
} as const

export type ZonesScalarFieldEnum = (typeof ZonesScalarFieldEnum)[keyof typeof ZonesScalarFieldEnum]


export const SectorsScalarFieldEnum = {
  id: 'id',
  name: 'name',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  church_id: 'church_id',
  zone_id: 'zone_id',
  supervisor_id: 'supervisor_id'
} as const

export type SectorsScalarFieldEnum = (typeof SectorsScalarFieldEnum)[keyof typeof SectorsScalarFieldEnum]


export const SubSectorsScalarFieldEnum = {
  id: 'id',
  name: 'name',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  sector_id: 'sector_id',
  supervisor_id: 'supervisor_id'
} as const

export type SubSectorsScalarFieldEnum = (typeof SubSectorsScalarFieldEnum)[keyof typeof SubSectorsScalarFieldEnum]


export const GroupsScalarFieldEnum = {
  id: 'id',
  name: 'name',
  leader_id: 'leader_id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  church_id: 'church_id',
  parent_id: 'parent_id'
} as const

export type GroupsScalarFieldEnum = (typeof GroupsScalarFieldEnum)[keyof typeof GroupsScalarFieldEnum]


export const GroupFieldsScalarFieldEnum = {
  id: 'id',
  group_id: 'group_id',
  key: 'key',
  label: 'label',
  type: 'type',
  value: 'value',
  required: 'required',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type GroupFieldsScalarFieldEnum = (typeof GroupFieldsScalarFieldEnum)[keyof typeof GroupFieldsScalarFieldEnum]


export const CellGoalsScalarFieldEnum = {
  id: 'id',
  church_id: 'church_id',
  cell_id: 'cell_id',
  event_id: 'event_id',
  target: 'target',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CellGoalsScalarFieldEnum = (typeof CellGoalsScalarFieldEnum)[keyof typeof CellGoalsScalarFieldEnum]


export const ReportsScalarFieldEnum = {
  id: 'id',
  church_id: 'church_id',
  scope: 'scope',
  title: 'title',
  description: 'description',
  color: 'color',
  publicToken: 'publicToken',
  cell_id: 'cell_id',
  group_id: 'group_id',
  zone_id: 'zone_id',
  sector_id: 'sector_id',
  sub_sector_id: 'sub_sector_id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ReportsScalarFieldEnum = (typeof ReportsScalarFieldEnum)[keyof typeof ReportsScalarFieldEnum]


export const ReportFieldsScalarFieldEnum = {
  id: 'id',
  report_id: 'report_id',
  key: 'key',
  label: 'label',
  type: 'type',
  value: 'value',
  options: 'options',
  validation: 'validation',
  visibilityRules: 'visibilityRules',
  required: 'required',
  order: 'order',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ReportFieldsScalarFieldEnum = (typeof ReportFieldsScalarFieldEnum)[keyof typeof ReportFieldsScalarFieldEnum]


export const ReportEntriesScalarFieldEnum = {
  id: 'id',
  church_id: 'church_id',
  report_id: 'report_id',
  scope: 'scope',
  cell_id: 'cell_id',
  group_id: 'group_id',
  zone_id: 'zone_id',
  sector_id: 'sector_id',
  sub_sector_id: 'sub_sector_id',
  status: 'status',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ReportEntriesScalarFieldEnum = (typeof ReportEntriesScalarFieldEnum)[keyof typeof ReportEntriesScalarFieldEnum]


export const ReportEntryValuesScalarFieldEnum = {
  id: 'id',
  entry_id: 'entry_id',
  report_field_id: 'report_field_id',
  value: 'value',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ReportEntryValuesScalarFieldEnum = (typeof ReportEntryValuesScalarFieldEnum)[keyof typeof ReportEntryValuesScalarFieldEnum]


export const MemberMinistryScalarFieldEnum = {
  id: 'id',
  memberId: 'memberId',
  ministryId: 'ministryId',
  church_id: 'church_id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type MemberMinistryScalarFieldEnum = (typeof MemberMinistryScalarFieldEnum)[keyof typeof MemberMinistryScalarFieldEnum]


export const FriendsScalarFieldEnum = {
  id: 'id',
  church_id: 'church_id',
  name: 'name',
  phone: 'phone',
  cell_id: 'cell_id',
  invited_by_id: 'invited_by_id',
  spiritual_father_id: 'spiritual_father_id',
  isBaptized: 'isBaptized',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type FriendsScalarFieldEnum = (typeof FriendsScalarFieldEnum)[keyof typeof FriendsScalarFieldEnum]


export const EventsScalarFieldEnum = {
  id: 'id',
  church_id: 'church_id',
  name: 'name',
  date: 'date',
  type: 'type',
  friendAttendanceGoal: 'friendAttendanceGoal',
  memberAttendanceGoal: 'memberAttendanceGoal',
  phase_id: 'phase_id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type EventsScalarFieldEnum = (typeof EventsScalarFieldEnum)[keyof typeof EventsScalarFieldEnum]


export const EventAttendancesScalarFieldEnum = {
  id: 'id',
  church_id: 'church_id',
  friend_id: 'friend_id',
  event_id: 'event_id',
  attended: 'attended',
  createdAt: 'createdAt'
} as const

export type EventAttendancesScalarFieldEnum = (typeof EventAttendancesScalarFieldEnum)[keyof typeof EventAttendancesScalarFieldEnum]


export const EventPhasesScalarFieldEnum = {
  id: 'id',
  name: 'name',
  color: 'color',
  church_id: 'church_id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type EventPhasesScalarFieldEnum = (typeof EventPhasesScalarFieldEnum)[keyof typeof EventPhasesScalarFieldEnum]


export const SortOrder = {
  asc: 'asc',
  desc: 'desc'
} as const

export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


export const NullableJsonNullValueInput = {
  DbNull: DbNull,
  JsonNull: JsonNull
} as const

export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


export const QueryMode = {
  default: 'default',
  insensitive: 'insensitive'
} as const

export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


export const NullsOrder = {
  first: 'first',
  last: 'last'
} as const

export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


export const JsonNullValueFilter = {
  DbNull: DbNull,
  JsonNull: JsonNull,
  AnyNull: AnyNull
} as const

export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]



/**
 * Field references
 */


/**
 * Reference to a field of type 'String'
 */
export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


/**
 * Reference to a field of type 'String[]'
 */
export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


/**
 * Reference to a field of type 'DateTime'
 */
export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


/**
 * Reference to a field of type 'DateTime[]'
 */
export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


/**
 * Reference to a field of type 'Int'
 */
export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


/**
 * Reference to a field of type 'Int[]'
 */
export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


/**
 * Reference to a field of type 'MemberRole'
 */
export type EnumMemberRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MemberRole'>
    


/**
 * Reference to a field of type 'MemberRole[]'
 */
export type ListEnumMemberRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MemberRole[]'>
    


/**
 * Reference to a field of type 'Gender'
 */
export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


/**
 * Reference to a field of type 'Gender[]'
 */
export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender[]'>
    


/**
 * Reference to a field of type 'GroupFieldType'
 */
export type EnumGroupFieldTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GroupFieldType'>
    


/**
 * Reference to a field of type 'GroupFieldType[]'
 */
export type ListEnumGroupFieldTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GroupFieldType[]'>
    


/**
 * Reference to a field of type 'Json'
 */
export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


/**
 * Reference to a field of type 'QueryMode'
 */
export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


/**
 * Reference to a field of type 'Boolean'
 */
export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


/**
 * Reference to a field of type 'ReportScope'
 */
export type EnumReportScopeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportScope'>
    


/**
 * Reference to a field of type 'ReportScope[]'
 */
export type ListEnumReportScopeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportScope[]'>
    


/**
 * Reference to a field of type 'ReportFieldType'
 */
export type EnumReportFieldTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportFieldType'>
    


/**
 * Reference to a field of type 'ReportFieldType[]'
 */
export type ListEnumReportFieldTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportFieldType[]'>
    


/**
 * Reference to a field of type 'ReportEntryStatus'
 */
export type EnumReportEntryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportEntryStatus'>
    


/**
 * Reference to a field of type 'ReportEntryStatus[]'
 */
export type ListEnumReportEntryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportEntryStatus[]'>
    


/**
 * Reference to a field of type 'Float'
 */
export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


/**
 * Reference to a field of type 'Float[]'
 */
export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    

/**
 * Batch Payload for updateMany & deleteMany & createMany
 */
export type BatchPayload = {
  count: number
}

export const defineExtension = runtime.Extensions.defineExtension as unknown as runtime.Types.Extensions.ExtendsHook<"define", TypeMapCb, runtime.Types.Extensions.DefaultArgs>
export type DefaultPrismaClient = PrismaClient
export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
export type PrismaClientOptions = ({
  /**
   * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-pg`.
   */
  adapter: runtime.SqlDriverAdapterFactory
  accelerateUrl?: never
} | {
  /**
   * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
   */
  accelerateUrl: string
  adapter?: never
}) & {
  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat
  /**
   * @example
   * ```
   * // Shorthand for `emit: 'stdout'`
   * log: ['query', 'info', 'warn', 'error']
   * 
   * // Emit as events only
   * log: [
   *   { emit: 'event', level: 'query' },
   *   { emit: 'event', level: 'info' },
   *   { emit: 'event', level: 'warn' }
   *   { emit: 'event', level: 'error' }
   * ]
   * 
   * / Emit as events and log to stdout
   * og: [
   *  { emit: 'stdout', level: 'query' },
   *  { emit: 'stdout', level: 'info' },
   *  { emit: 'stdout', level: 'warn' }
   *  { emit: 'stdout', level: 'error' }
   * 
   * ```
   * Read more in our [docs](https://pris.ly/d/logging).
   */
  log?: (LogLevel | LogDefinition)[]
  /**
   * The default values for transactionOptions
   * maxWait ?= 2000
   * timeout ?= 5000
   */
  transactionOptions?: {
    maxWait?: number
    timeout?: number
    isolationLevel?: TransactionIsolationLevel
  }
  /**
   * Global configuration for omitting model fields by default.
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   omit: {
   *     user: {
   *       password: true
   *     }
   *   }
   * })
   * ```
   */
  omit?: GlobalOmitConfig
  /**
   * SQL commenter plugins that add metadata to SQL queries as comments.
   * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   adapter,
   *   comments: [
   *     traceContext(),
   *     queryInsights(),
   *   ],
   * })
   * ```
   */
  comments?: runtime.SqlCommenterPlugin[]
}
export type GlobalOmitConfig = {
  churches?: Prisma.ChurchesOmit
  networks?: Prisma.NetworksOmit
  members?: Prisma.MembersOmit
  ministries?: Prisma.MinistriesOmit
  cells?: Prisma.CellsOmit
  zones?: Prisma.ZonesOmit
  sectors?: Prisma.SectorsOmit
  subSectors?: Prisma.SubSectorsOmit
  groups?: Prisma.GroupsOmit
  groupFields?: Prisma.GroupFieldsOmit
  cellGoals?: Prisma.CellGoalsOmit
  reports?: Prisma.ReportsOmit
  reportFields?: Prisma.ReportFieldsOmit
  reportEntries?: Prisma.ReportEntriesOmit
  reportEntryValues?: Prisma.ReportEntryValuesOmit
  memberMinistry?: Prisma.MemberMinistryOmit
  friends?: Prisma.FriendsOmit
  events?: Prisma.EventsOmit
  eventAttendances?: Prisma.EventAttendancesOmit
  eventPhases?: Prisma.EventPhasesOmit
}

/* Types for Logging */
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}

export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

export type GetLogType<T> = CheckIsLogLevel<
  T extends LogDefinition ? T['level'] : T
>;

export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
  ? GetLogType<T[number]>
  : never;

export type QueryEvent = {
  timestamp: Date
  query: string
  params: string
  duration: number
  target: string
}

export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
/* End Types for Logging */


export type PrismaAction =
  | 'findUnique'
  | 'findUniqueOrThrow'
  | 'findMany'
  | 'findFirst'
  | 'findFirstOrThrow'
  | 'create'
  | 'createMany'
  | 'createManyAndReturn'
  | 'update'
  | 'updateMany'
  | 'updateManyAndReturn'
  | 'upsert'
  | 'delete'
  | 'deleteMany'
  | 'executeRaw'
  | 'queryRaw'
  | 'aggregate'
  | 'count'
  | 'runCommandRaw'
  | 'findRaw'
  | 'groupBy'

/**
 * `PrismaClient` proxy available in interactive transactions.
 */
export type TransactionClient = Omit<DefaultPrismaClient, runtime.ITXClientDenyList>

